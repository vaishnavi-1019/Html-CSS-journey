<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pro Voice-Controlled To-Do App</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            background-color: #f8f9fa;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 20px;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }
        h1 {
            text-align: center;
            color: #343a40;
            margin-bottom: 20px;
        }
        .command-examples {
            background: #e9ecef;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .input-group {
            margin-bottom: 20px;
        }
        #taskInput {
            border-radius: 0.375rem 0 0 0.375rem;
        }
        #addButton {
            border-radius: 0;
        }
        #voiceButton {
            border-radius: 0 0.375rem 0.375rem 0;
            background-color: #007bff;
            color: white;
            font-size: 1.2rem;
        }
        #voiceButton:hover {
            background-color: #0056b3;
        }
        .list-group-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: none;
            border-bottom: 1px solid #dee2e6;
            padding: 15px;
            transition: background-color 0.2s;
        }
        .list-group-item:hover {
            background-color: #f1f3f5;
        }
        .task-number {
            font-weight: bold;
            margin-right: 10px;
            color: #6c757d;
        }
        .task-text {
            flex-grow: 1;
        }
        .delete-btn {
            color: #dc3545;
            cursor: pointer;
            font-size: 1.2rem;
            margin-left: 10px;
        }
        .delete-btn:hover {
            color: #c82333;
        }
        #status {
            text-align: center;
            margin-top: 10px;
            font-style: italic;
            color: #28a745;
            transition: opacity 0.5s;
        }
        #deletedTasks {
            margin-top: 30px;
            background: #f8d7da;
            padding: 15px;
            border-radius: 10px;
            display: none;
        }
        #deletedTasks h3 {
            color: #721c24;
            margin-bottom: 10px;
        }
        .deleted-list-item {
            background: #f5c6cb;
            padding: 10px;
            margin-bottom: 5px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Professional Voice-Controlled To-Do App</h1>
        <div class="command-examples">
            <p><strong>Speak commands like:</strong></p>
            <ul>
                <li>"Add task buy groceries" - Adds a new task</li>
                <li>"Delete task 2" - Deletes task at position 2</li>
                <li>"Edit task 3 to finish report" - Edits task 3</li>
                <li>"Restore last" - Restores the last deleted task</li>
                <li>"Restore all" - Restores all deleted tasks</li>
                <li>"Clear all" - Clears all tasks</li>
            </ul>
            <p>Use the mic button to start speaking. Manual input is available as a fallback.</p>
        </div>
        <div class="input-group">
            <input type="text" id="taskInput" class="form-control" placeholder="Type task here (optional)...">
            <button id="addButton" class="btn btn-primary">Add</button>
            <button id="voiceButton" class="btn">üé§</button>
        </div>
        <ul id="taskList" class="list-group"></ul>
        <div id="status"></div>
        <div id="deletedTasks">
            <h3>Deleted Tasks (for restore)</h3>
            <ul id="deletedList"></ul>
        </div>
    </div>

    <script>
        const taskInput = document.getElementById('taskInput');
        const addButton = document.getElementById('addButton');
        const voiceButton = document.getElementById('voiceButton');
        const taskList = document.getElementById('taskList');
        const status = document.getElementById('status');
        const deletedList = document.getElementById('deletedList');
        const deletedTasksSection = document.getElementById('deletedTasks');

        let tasks = [];
        let deletedTasks = [];

        // Load from local storage
        if (localStorage.getItem('tasks')) {
            tasks = JSON.parse(localStorage.getItem('tasks'));
            renderTasks();
        }
        if (localStorage.getItem('deletedTasks')) {
            deletedTasks = JSON.parse(localStorage.getItem('deletedTasks'));
            renderDeleted();
        }

        // Manual add
        addButton.addEventListener('click', () => {
            addTask(taskInput.value);
            taskInput.value = '';
        });

        // Voice setup
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (SpeechRecognition) {
            const recognition = new SpeechRecognition();
            recognition.continuous = false;
            recognition.interimResults = false;
            recognition.lang = 'en-US';

            voiceButton.addEventListener('click', () => {
                recognition.start();
                status.textContent = 'Listening...';
                status.style.color = '#ffc107';
            });

            recognition.onresult = (event) => {
                const command = event.results[0][0].transcript.toLowerCase().trim();
                status.textContent = `Heard: "${command}"`;
                status.style.color = '#17a2b8';
                processCommand(command);
            };

            recognition.onerror = (event) => {
                status.textContent = `Error: ${event.error}`;
                status.style.color = '#dc3545';
            };

            recognition.onend = () => {
                setTimeout(() => { status.textContent = ''; }, 3000);
            };
        } else {
            voiceButton.disabled = true;
            status.textContent = 'Speech recognition not supported.';
            status.style.color = '#dc3545';
        }

        function processCommand(command) {
            if (command.startsWith('add task')) {
                const taskText = command.replace('add task', '').trim();
                if (taskText) addTask(taskText);
            } else if (command.startsWith('delete task')) {
                const index = parseInt(command.replace('delete task', '').trim()) - 1;
                if (!isNaN(index) && index >= 0 && index < tasks.length) deleteTask(index);
            } else if (command.startsWith('edit task')) {
                const parts = command.replace('edit task', '').trim().split(' to ');
                if (parts.length === 2) {
                    const index = parseInt(parts[0].trim()) - 1;
                    const newText = parts[1].trim();
                    if (!isNaN(index) && index >= 0 && index < tasks.length && newText) editTask(index, newText);
                }
            } else if (command === 'restore last') {
                restoreLast();
            } else if (command === 'restore all') {
                restoreAll();
            } else if (command === 'clear all') {
                clearAll();
            } else {
                status.textContent = 'Command not recognized. Try again.';
                status.style.color = '#dc3545';
            }
        }

        function addTask(text) {
            if (text) {
                tasks.push(text);
                saveTasks();
                renderTasks();
                updateStatus('Task added!', '#28a745');
            }
        }

        function deleteTask(index) {
            deletedTasks.push(tasks[index]);
            tasks.splice(index, 1);
            saveTasks();
            renderTasks();
            renderDeleted();
            updateStatus('Task deleted!', '#28a745');
        }

        function editTask(index, newText) {
            tasks[index] = newText;
            saveTasks();
            renderTasks();
            updateStatus('Task edited!', '#28a745');
        }

        function restoreLast() {
            if (deletedTasks.length > 0) {
                tasks.push(deletedTasks.pop());
                saveTasks();
                renderTasks();
                renderDeleted();
                updateStatus('Last task restored!', '#28a745');
            }
        }

        function restoreAll() {
            tasks = tasks.concat(deletedTasks);
            deletedTasks = [];
            saveTasks();
            renderTasks();
            renderDeleted();
            updateStatus('All tasks restored!', '#28a745');
        }

        function clearAll() {
            deletedTasks = deletedTasks.concat(tasks);
            tasks = [];
            saveTasks();
            renderTasks();
            renderDeleted();
            updateStatus('All tasks cleared!', '#28a745');
        }

        function renderTasks() {
            taskList.innerHTML = '';
            tasks.forEach((task, index) => {
                const li = document.createElement('li');
                li.className = 'list-group-item';
                li.innerHTML = `
                    <span class="task-number">${index + 1}.</span>
                    <span class="task-text">${task}</span>
                    <span class="delete-btn" onclick="deleteTask(${index})">‚ùå</span>
                `;
                taskList.appendChild(li);
            });
        }

        function renderDeleted() {
            deletedList.innerHTML = '';
            if (deletedTasks.length > 0) {
                deletedTasksSection.style.display = 'block';
                deletedTasks.forEach(task => {
                    const li = document.createElement('li');
                    li.className = 'deleted-list-item';
                    li.textContent = task;
                    deletedList.appendChild(li);
                });
            } else {
                deletedTasksSection.style.display = 'none';
            }
        }

        function saveTasks() {
            localStorage.setItem('tasks', JSON.stringify(tasks));
            localStorage.setItem('deletedTasks', JSON.stringify(deletedTasks));
        }

        function updateStatus(message, color) {
            status.textContent = message;
            status.style.color = color;
            setTimeout(() => { status.textContent = ''; }, 3000);
        }

        <!DOCTYPE html>
<html lang="en" class="h-full">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pro Voice To-Do</title>

  <!-- Tailwind (purged) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      darkMode: 'class',
      content: ['./index.html'],
      theme: { extend: {} }
    }
  </script>

  <!-- Preact (3 KB) -->
  <script type="module">
    import { h, render } from 'https://esm.run/preact';
    import { useState, useEffect, useCallback } from 'https://esm.run/preact/hooks';
    import { create } from 'https://esm.run/zustand';

    /* ---------- Zustand Store ---------- */
    const useStore = create(set => ({
      tasks: [],
      deleted: [],
      load: () => {
        const t = localStorage.getItem('tasks');
        const d = localStorage.getItem('deleted');
        set({ tasks: t ? JSON.parse(t) : [], deleted: d ? JSON.parse(d) : [] });
      },
      save: (tasks, deleted) => {
        localStorage.setItem('tasks', JSON.stringify(tasks));
        localStorage.setItem('deleted', JSON.stringify(deleted));
      },
      add: text => set(state => {
        const tasks = [...state.tasks, text];
        state.save(tasks, state.deleted);
        return { tasks };
      }),
      remove: idx => set(state => {
        const task = state.tasks[idx];
        const tasks = state.tasks.filter((_, i) => i !== idx);
        const deleted = [...state.deleted, task];
        state.save(tasks, deleted);
        return { tasks, deleted };
      }),
      edit: (idx, text) => set(state => {
        const tasks = state.tasks.map((t, i) => i === idx ? text : t);
        state.save(tasks, state.deleted);
        return { tasks };
      }),
      restoreLast: () => set(state => {
        if (!state.deleted.length) return state;
        const [last, ...rest] = state.deleted.slice().reverse();
        const tasks = [...state.tasks, last];
        const deleted = rest.reverse();
        state.save(tasks, deleted);
        return { tasks, deleted };
      }),
      restoreAll: () => set(state => {
        const tasks = [...state.tasks, ...state.deleted];
        const deleted = [];
        state.save(tasks, deleted);
        return { tasks, deleted };
      }),
      clearAll: () => set(state => {
        const deleted = [...state.deleted, ...state.tasks];
        const tasks = [];
        state.save(tasks, deleted);
        return { tasks, deleted };
      })
    }));

    /* ---------- Speech Worker ---------- */
    const speechWorker = new Worker(URL.createObjectURL(new Blob([`
      let recognition;
      self.onmessage = e => {
        if (e.data === 'start') {
          const SpeechRecognition = self.webkitSpeechRecognition || self.SpeechRecognition;
          recognition = new SpeechRecognition();
          recognition.lang = 'en-US';
          recognition.continuous = false;
          recognition.interimResults = false;

          recognition.onresult = ev => {
            const cmd = ev.results[0][0].transcript.toLowerCase().trim();
            self.postMessage({type:'result', cmd});
          };
          recognition.onerror = ev => self.postMessage({type:'error', msg:ev.error});
          recognition.onend = () => self.postMessage({type:'end'});

          recognition.start();
        }
      };
    `], {type:'application/javascript'})));

    /* ---------- Main Component ---------- */
    const App = () => {
      const { tasks, deleted, add, remove, edit, restoreLast, restoreAll, clearAll, load } = useStore();
      const [status, setStatus] = useState('');
      const [listening, setListening] = useState(false);

      // Load on mount
      useEffect(() => load(), [load]);

      // Speech handling
      useEffect(() => {
        const handler = e => {
          if (e.data.type === 'result') {
            setListening(false);
            processCommand(e.data.cmd);
          } else if (e.data.type === 'error') {
            setStatus(`Error: ${e.data.msg}`);
            setListening(false);
          } else if (e.data.type === 'end') {
            setListening(false);
          }
        };
        speechWorker.addEventListener('message', handler);
        return () => speechWorker.removeEventListener('message', handler);
      }, []);

      const startListening = () => {
        setListening(true);
        setStatus('Listening‚Ä¶');
        speechWorker.postMessage('start');
      };

      const processCommand = cmd => {
        setStatus(`Heard: "${cmd}"`);
        if (cmd.startsWith('add task')) {
          const txt = cmd.slice(8).trim();
          if (txt) add(txt);
        } else if (cmd.startsWith('delete task')) {
          const idx = parseInt(cmd.slice(11).trim()) - 1;
          if (!isNaN(idx) && idx >= 0 && idx < tasks.length) remove(idx);
        } else if (cmd.startsWith('edit task')) {
          const parts = cmd.slice(9).trim().split(' to ');
          if (parts.length === 2) {
            const idx = parseInt(parts[0].trim()) - 1;
            const txt = parts[1].trim();
            if (!isNaN(idx) && idx >= 0 && idx < tasks.length && txt) edit(idx, txt);
          }
        } else if (cmd === 'restore last') {
          restoreLast();
        } else if (cmd === 'restore all') {
          restoreAll();
        } else if (cmd === 'clear all') {
          clearAll();
        } else {
          setStatus('Unknown command');
        }
        setTimeout(() => setStatus(''), 2500);
      };

      // Event delegation for delete
      const handleListClick = useCallback(e => {
        if (e.target.dataset.idx !== undefined) {
          remove(parseInt(e.target.dataset.idx));
        }
      }, [remove]);

      return h('div', { class: 'min-h-screen bg-gray-50 dark:bg-gray-900 p-4 flex items-center justify-center' },
        h('div', { class: 'w-full max-w-2xl bg-white dark:bg-gray-800 rounded-xl shadow-xl p-6 space-y-6' },
          // Header
          h('h1', { class: 'text-3xl font-bold text-center text-gray-800 dark:text-gray-100' }, 'Voice To-Do'),

          // Command guide
          h('details', { class: 'bg-gray-100 dark:bg-gray-700 p-3 rounded-lg' },
            h('summary', { class: 'cursor-pointer font-medium' }, 'Voice Commands'),
            h('ul', { class: 'list-disc pl-5 mt-2 space-y-1 text-sm' },
              ['add task <text>', 'delete task <n>', 'edit task <n> to <text>', 'restore last', 'restore all', 'clear all'].map(c =>
                h('li', { key: c }, c)
              )
            )
          ),

          // Controls
          h('div', { class: 'flex gap-2' },
            h('input', {
              type: 'text',
              placeholder: 'or type here‚Ä¶',
              class: 'flex-1 px-4 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500',
              onKeyDown: e => e.key === 'Enter' && (add(e.target.value), e.target.value = '')
            }),
            h('button', {
              class: 'px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition',
              onClick: () => add(document.querySelector('input').value)
            }, 'Add'),
            h('button', {
              class: `px-4 py-2 rounded-lg transition ${listening ? 'bg-red-600 animate-pulse' : 'bg-green-600 hover:bg-green-700'} text-white`,
              onClick: startListening,
              'aria-label': 'Start voice command'
            }, listening ? '‚èπ' : 'üé§')
          ),

          // Status
          status && h('p', { class: 'text-center text-sm italic text-gray-600 dark:text-gray-300' }, status),

          // Task list
          h('ul', {
            class: 'space-y-2',
            onClick: handleListClick
          },
            tasks.map((t, i) =>
              h('li', {
                key: i,
                class: 'flex items-center justify-between p-3 bg-gray-50 dark:bg-gray-700 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-600 transition'
              },
                h('span', { class: 'flex-1' }, `${i + 1}. ${t}`),
                h('button', {
                  'data-idx': i,
                  class: 'text-red-600 hover:text-red-800',
                  'aria-label': `Delete task ${i + 1}`
                }, '√ó')
              )
            )
          ),

          // Deleted (restore) section
          deleted.length > 0 && h('details', { class: 'bg-red-50 dark:bg-red-900 p-3 rounded-lg' },
            h('summary', { class: 'cursor-pointer font-medium text-red-800 dark:text-red-200' }, `Deleted (${deleted.length})`),
            h('ul', { class: 'mt-2 space-y-1 text-sm' },
              deleted.map((t, i) => h('li', { key: i, class: 'bg-red-100 dark:bg-red-800 px-2 py-1 rounded' }, t))
            ),
            h('div', { class: 'mt-2 flex gap-2' },
              h('button', { class: 'text-xs px-2 py-1 bg-green-600 text-white rounded hover:bg-green-700', onClick: restoreLast }, 'Restore last'),
              h('button', { class: 'text-xs px-2 py-1 bg-green-600 text-white rounded hover:bg-green-700', onClick: restoreAll }, 'Restore all')
            )
          )
        )
      );
    };

    render(h(App), document.body);
  </script>
</head>
</body>
